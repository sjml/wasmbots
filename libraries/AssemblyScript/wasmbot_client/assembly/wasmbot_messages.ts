// This file was automatically generated by Beschi v0.3.1
// <https://github.com/sjml/beschi>
// Do not edit directly.

/*
DATA PROTOCOL
-----------------
[meta]
namespace = "WasmBots"
list_size_type = "uint16"
string_size_type = "byte"

# used internally for handling host <-> module mishaps
[[messages]]
_name = "_Error"
description = "string"

[[enums]]
_name = "GameMode"
_values = [
	"Wander", # the proof-of-concept "navigate with no stakes" mode
	"Attain", # find the amulet
]

# initial setup message that you can either accept or reject
[[messages]]
_name = "InitialParameters"
paramsVersion = "uint16"       # version of this very message, so you know if you can parse the rest
engineVersionMajor = "uint16"  # major version of engine
engineVersionMinor = "uint16"  # minor version of engine
engineVersionPatch = "uint16"  # patch version of engine
diagonalMovement = "bool"      # if false, any attempted diagonal move will be Invalid
playerStride = "byte"          # how far you can move on a given turn
playerOpenReach = "byte"       # the distance at which you can open things (doors, chests)
gameMode = "GameMode"          # what type of game we're going to play

[[structs]]
_name = "Point"
x = "int16"
y = "int16"


[[enums]]
_name = "MoveResult"
_values = [
	"Succeeded",  # your move worked (ex: attack hit, moved successfully)
	"Failed",     # your move did not work (ex: attack missed, moved into wall)
	"Invalid",    # your move was not allowed by the system (ex: tried diagonal movement when not allowed, targeted something out of range)
	"Error",      # your move was not understood (ex: malformed message, missing data)
]

[[enums]]
_name = "TileType"
_values = [
	"Void",        # you don't know what's there; might be off the edge of the map, or maybe just behind a wall
	"Floor",       # an open space you can move to
	"OpenDoor",    # a door space that you can pass through or take a turn to target with Close
	"ClosedDoor",  # an impassable door space that you can take a turn to target with Open
	"Wall",        # an impassable space
]

[[enums]]
_name = "Direction"
_values = [
	"North",
	"Northeast",
	"East",
	"Southeast",
	"South",
	"Southwest",
	"West",
	"Northwest",
]

[[enums]]
_name = "EntityType"
_values = [
	"Player",
	"Item",
]

[[structs]]
_name = "Entity"
id = "uint32"
type = "EntityType"
surroundingsIndex = "uint16"
label = "string"
dataByteA = "byte"
dataByteB = "byte"
dataIntA = "int32"
dataIntB = "int32"

[[enums]]
_name = "ItemType"
_values = [
	"Stone",
	"Amulet",
]

# player receives every tick
[[messages]]
_name = "PresentCircumstances"  # describes your immediate situation and surroundings at the start of this turn
lastTickDuration = "uint32"     # how long, in milliseconds, you took on the last tick (will be 0 on initial turn)
lastMoveResult = "MoveResult"   # the result of your last turn (will be Succeeded on initial turn)
currentHitPoints = "uint16"     # how many hit points you have
surroundings = "[TileType]"     # array of tiles representing your immediate surroundings as a square with you in the middle
surroundingsRadius = "byte"     # radius (from you) of the surroundings, so the side of a square is (this * 2) + 1


### moves that the player submits

[[messages]]
_name = "Wait"  # no-op; don't do anything and wait for the next tick

[[messages]]
_name = "Resign"  # give up the game; you will receive no more tick calls after submitting this move

[[messages]]
_name = "MoveTo"         # move to a new tile
direction = "Direction"  # which way to move
distance = "byte"        # how far to move (can usually just be 1, but might be modified); if you put a number that is beyond your max range, the move will be Invalid

[[messages]]
_name = "Open"     # open (a door, a chest, etc.) at a specific tile
target = "Point"   # the position *relative to you* that you want to try to open; can usually only be one square away (manhattan distance); if already opened, move will fail; if target is not openable, move will be Invalid

[[messages]]
_name = "Close"    # close (a door, a chest, etc.) at a specific tile
target = "Point"   # the position *relative to you* that you want to try to close; can usually only be one square away (manhattan distance); if already closed, move will fail; if target is not closable, move will be Invalid

-----------------
END DATA PROTOCOL
*/



export class DataAccess {
	data: DataView;
	currentOffset: u32;
	hasError: bool;

	constructor(buffer: DataView) {
		this.currentOffset = 0;
		this.data = buffer;
		this.hasError = false;
	}

	isFinished(): bool {
		return this.currentOffset > (this.data.byteLength as u32);
	}

	getByte(): u8 {
		if (this.currentOffset + 1 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getUint8(this.currentOffset);
		this.currentOffset += 1;
		return ret;
	}

	getBool(): bool {
		return this.getByte() > 0;
	}

	getInt16(): i16 {
		if (this.currentOffset + 2 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getInt16(this.currentOffset, true);
		this.currentOffset += 2;
		return ret;
	}

	getUint16(): u16 {
		if (this.currentOffset + 2 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getUint16(this.currentOffset, true);
		this.currentOffset += 2;
		return ret;
	}

	getInt32(): i32 {
		if (this.currentOffset + 4 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getInt32(this.currentOffset, true);
		this.currentOffset += 4;
		return ret;
	}

	getUint32(): u32 {
		if (this.currentOffset + 4 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getUint32(this.currentOffset, true);
		this.currentOffset += 4;
		return ret;
	}

	getInt64(): i64 {
		if (this.currentOffset + 8 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getInt64(this.currentOffset, true);
		this.currentOffset += 8;
		return ret;
	}

	getUint64(): u64 {
		if (this.currentOffset + 8 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getUint64(this.currentOffset, true);
		this.currentOffset += 8;
		return ret;
	}

	getFloat32(): f32 {
		if (this.currentOffset + 4 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getFloat32(this.currentOffset, true);
		this.currentOffset += 4;
		return ret;
	}

	getFloat64(): f64 {
		if (this.currentOffset + 8 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return 0;
		}
		const ret = this.data.getFloat64(this.currentOffset, true);
		this.currentOffset += 8;
		return ret;
	}

	getString(): string {
		const len = this.getByte();
		if (this.hasError) {
				return "";
		}
		if (this.currentOffset + len > (this.data.byteLength as u32)) {
				this.hasError = true;
				return "";
		}
		const strBuffer = new Uint8Array(len);
		for (let i = 0; i < strBuffer.byteLength; i++) {
				strBuffer[i] = this.getByte();
		}
		return String.UTF8.decode(strBuffer.buffer, false);
	}


	setByte(val: u8): void {
		if (this.currentOffset + 1 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setUint8(this.currentOffset, val);
		this.currentOffset += 1;
	}

	setBool(val: bool): void {
		this.setByte(val ? 1 : 0);
	}

	setInt16(val: i16): void {
		if (this.currentOffset + 2 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setInt16(this.currentOffset, val, true);
		this.currentOffset += 2;
	}

	setUint16(val: u16): void {
		if (this.currentOffset + 2 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setUint16(this.currentOffset, val, true);
		this.currentOffset += 2;
	}

	setInt32(val: i32): void {
		if (this.currentOffset + 4 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setInt32(this.currentOffset, val, true);
		this.currentOffset += 4;
	}

	setUint32(val: u32): void {
		if (this.currentOffset + 4 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setUint32(this.currentOffset, val, true);
		this.currentOffset += 4;
	}

	setInt64(val: i64): void {
		if (this.currentOffset + 8 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setInt64(this.currentOffset, val, true);
		this.currentOffset += 8;
	}

	setUint64(val: u64): void {
		if (this.currentOffset + 8 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setUint64(this.currentOffset, val, true);
		this.currentOffset += 8;
	}

	setFloat32(val: f32): void {
		if (this.currentOffset + 4 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setFloat32(this.currentOffset, val, true);
		this.currentOffset += 4;
	}

	setFloat64(val: f64): void {
		if (this.currentOffset + 8 > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		this.data.setFloat64(this.currentOffset, val, true);
		this.currentOffset += 8;
	}

	setString(val: string): void {
		const strBuffer = String.UTF8.encode(val, false);
		const bufferArray = Uint8Array.wrap(strBuffer);
		this.setByte(strBuffer.byteLength as u8);
		if (this.hasError) {
				return;
		}
		if (this.currentOffset + bufferArray.byteLength > (this.data.byteLength as u32)) {
				this.hasError = true;
				return;
		}
		for (let i = 0; i < bufferArray.byteLength; i++) {
			this.setByte(bufferArray[i] as u8);
		}
	}
}

export abstract class Message {
	abstract getMessageType(): MessageType;
	abstract writeBytes(dv: DataView, tag: bool): bool;
	abstract writeBytesDA(da: DataAccess, tag: bool): bool;
	abstract getSizeInBytes(): usize;

	static fromBytes(data: DataView): Message | null {
		const da = new DataAccess(data);
		return this.fromBytesDA(da);
	};

	static fromBytesDA(data: DataAccess): Message | null {
		const msgList = ProcessRawBytes(data, 1);
		if (msgList.length == 0) {
			return null;
		}
		return msgList[0];
	}
}

export function GetPackedSize(msgList: Message[]): usize {
	let size: usize = 0;
	for (let i = 0; i < msgList.length; i++) {
		size += msgList[i].getSizeInBytes();
	}
	size += msgList.length;
	size += 9;
	return size;
}

export function PackMessages(msgList: Message[], data: DataView): void {
	const da = new DataAccess(data);
	const headerBytes = String.UTF8.encode("BSCI", false);
	const arr = Uint8Array.wrap(headerBytes);
	for (let i = 0; i < arr.byteLength; i++) {
		da.setByte(arr[i] as u8);
		if (da.hasError) { return; }
}
	da.setUint32(msgList.length);
	if (da.hasError) { return; }
	for (let i = 0; i < msgList.length; i++) {
			msgList[i].writeBytesDA(da, true);
			if (da.hasError) { return; }
	}
	da.setByte(0);
}

export function UnpackMessages(data: DataView): Message[] {
	const da = new DataAccess(data);
	if (da.data.byteLength < 12) {
		throw new Error("Packed message buffer is too short.");
	}
	const headerBuffer = new Uint8Array(4);
	for (let i = 0; i < 4; i++) {
		headerBuffer[i] = da.getByte();
	}
	const headerLabel = String.UTF8.decode(headerBuffer.buffer, false);
	if (headerLabel !== "BSCI") {
		throw new Error("Packed message buffer has invalid header: " + headerLabel);
	}
	const msgCount = da.getUint32();
	if (msgCount == 0) {
		return [];
	}
	const dv = new DataView(data.buffer, da.currentOffset, data.byteLength - da.currentOffset);
	const msgList = ProcessRawBytes(dv, msgCount);
	if (msgList.length == 0) {
		throw new Error("No messages in buffer.");
	}
	if (msgList.length != msgCount) {
		throw new Error("Unexpected number of messages in buffer.");
	}
	return msgList;
}

export enum MessageType {
	_ErrorType = 1,
	InitialParametersType = 2,
	PresentCircumstancesType = 3,
	WaitType = 4,
	ResignType = 5,
	MoveToType = 6,
	OpenType = 7,
	CloseType = 8,
	_Unknown,
}

export function ProcessRawBytes(data: DataView, max: number): Message[] {
	const da = new DataAccess(data);
	return ProcessRawBytesDA(da, max);
}

export function ProcessRawBytesDA(da: DataAccess, max: number): Message[] {
	const msgList: Message[] = [];
	if (max == 0) {
		return msgList;
	}
	while (!da.isFinished() && (max < 0 || msgList.length < max)) {
		const msgType: u8 = da.getByte();
		let newMsg: Message | null;
		switch (msgType) {
			case 0:
				return msgList;
			case MessageType._ErrorType:
				newMsg = _Error.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.InitialParametersType:
				newMsg = InitialParameters.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.PresentCircumstancesType:
				newMsg = PresentCircumstances.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.WaitType:
				newMsg = Wait.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.ResignType:
				newMsg = Resign.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.MoveToType:
				newMsg = MoveTo.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.OpenType:
				newMsg = Open.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			case MessageType.CloseType:
				newMsg = Close.fromBytesDA(da);
				if (newMsg == null) {
					return msgList;
				}
				msgList.push(newMsg);
				break;
			default:
				return msgList;
		}
	}
	return msgList;
}

export enum GameMode {
	Wander = 0,
	Attain = 1,
	_Unknown,
}

export enum MoveResult {
	Succeeded = 0,
	Failed = 1,
	Invalid = 2,
	Error = 3,
	_Unknown,
}

export enum TileType {
	Void = 0,
	Floor = 1,
	OpenDoor = 2,
	ClosedDoor = 3,
	Wall = 4,
	_Unknown,
}

export enum Direction {
	North = 0,
	Northeast = 1,
	East = 2,
	Southeast = 3,
	South = 4,
	Southwest = 5,
	West = 6,
	Northwest = 7,
	_Unknown,
}

export enum EntityType {
	Player = 0,
	Item = 1,
	_Unknown,
}

export enum ItemType {
	Stone = 0,
	Amulet = 1,
	_Unknown,
}

export class Point {
	x: i16 = 0;
	y: i16 = 0;

	static fromBytes(da: DataAccess): Point | null {
		const nPoint = new Point();
		nPoint.x = da.getInt16();
		if (da.hasError) { return null; }
		nPoint.y = da.getInt16();
		if (da.hasError) { return null; }
		return nPoint;
	}

	writeBytes(da: DataAccess): bool {
		da.setInt16(this.x);
		if (da.hasError) { return false; }
		da.setInt16(this.y);
		if (da.hasError) { return false; }
		return true;
	}
}

export class Entity {
	id: u32 = 0;
	type: EntityType = EntityType.Player;
	surroundingsIndex: u16 = 0;
	label: string = "";
	dataByteA: u8 = 0;
	dataByteB: u8 = 0;
	dataIntA: i32 = 0;
	dataIntB: i32 = 0;

	static fromBytes(da: DataAccess): Entity | null {
		const nEntity = new Entity();
		nEntity.id = da.getUint32();
		if (da.hasError) { return null; }
		let _type = da.getByte();
		if (da.hasError) { return null; }
		if (_type < 0 || _type >= (EntityType._Unknown as u8)) {
			_type = EntityType._Unknown as u8;
		}
		nEntity.type = _type;
		nEntity.surroundingsIndex = da.getUint16();
		if (da.hasError) { return null; }
		nEntity.label = da.getString();
		if (da.hasError) { return null; }
		nEntity.dataByteA = da.getByte();
		if (da.hasError) { return null; }
		nEntity.dataByteB = da.getByte();
		if (da.hasError) { return null; }
		nEntity.dataIntA = da.getInt32();
		if (da.hasError) { return null; }
		nEntity.dataIntB = da.getInt32();
		if (da.hasError) { return null; }
		return nEntity;
	}

	writeBytes(da: DataAccess): bool {
		da.setUint32(this.id);
		if (da.hasError) { return false; }
		da.setByte(this.type as u8);
		if (da.hasError) { return false; }
		da.setUint16(this.surroundingsIndex);
		if (da.hasError) { return false; }
		da.setString(this.label);
		if (da.hasError) { return false; }
		da.setByte(this.dataByteA);
		if (da.hasError) { return false; }
		da.setByte(this.dataByteB);
		if (da.hasError) { return false; }
		da.setInt32(this.dataIntA);
		if (da.hasError) { return false; }
		da.setInt32(this.dataIntB);
		if (da.hasError) { return false; }
		return true;
	}
}

export class _Error extends Message {
	description: string = "";

	getMessageType() : MessageType { return MessageType._ErrorType; }

	getSizeInBytes(): usize {
		let size: usize = 0;
		size += String.UTF8.encode(this.description, false).byteLength;
		size += 1;
		return size;
	}

	static override fromBytes(data: DataView): _Error | null {
		const da = new DataAccess(data);
		return _Error.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): _Error | null {
		const n_Error = new _Error();
		n_Error.description = da.getString();
		if (da.hasError) { return null; }
		return n_Error;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType._ErrorType as u8);
			if (da.hasError) { return false; }
		}
		da.setString(this.description);
		if (da.hasError) { return false; }
		return true;
	}
}

export class InitialParameters extends Message {
	paramsVersion: u16 = 0;
	engineVersionMajor: u16 = 0;
	engineVersionMinor: u16 = 0;
	engineVersionPatch: u16 = 0;
	diagonalMovement: bool = 0;
	playerStride: u8 = 0;
	playerOpenReach: u8 = 0;
	gameMode: GameMode = GameMode.Wander;

	getMessageType() : MessageType { return MessageType.InitialParametersType; }

	getSizeInBytes(): usize {
		return 12;
	}

	static override fromBytes(data: DataView): InitialParameters | null {
		const da = new DataAccess(data);
		return InitialParameters.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): InitialParameters | null {
		const nInitialParameters = new InitialParameters();
		nInitialParameters.paramsVersion = da.getUint16();
		if (da.hasError) { return null; }
		nInitialParameters.engineVersionMajor = da.getUint16();
		if (da.hasError) { return null; }
		nInitialParameters.engineVersionMinor = da.getUint16();
		if (da.hasError) { return null; }
		nInitialParameters.engineVersionPatch = da.getUint16();
		if (da.hasError) { return null; }
		nInitialParameters.diagonalMovement = da.getBool();
		if (da.hasError) { return null; }
		nInitialParameters.playerStride = da.getByte();
		if (da.hasError) { return null; }
		nInitialParameters.playerOpenReach = da.getByte();
		if (da.hasError) { return null; }
		let _gameMode = da.getByte();
		if (da.hasError) { return null; }
		if (_gameMode < 0 || _gameMode >= (GameMode._Unknown as u8)) {
			_gameMode = GameMode._Unknown as u8;
		}
		nInitialParameters.gameMode = _gameMode;
		return nInitialParameters;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.InitialParametersType as u8);
			if (da.hasError) { return false; }
		}
		da.setUint16(this.paramsVersion);
		if (da.hasError) { return false; }
		da.setUint16(this.engineVersionMajor);
		if (da.hasError) { return false; }
		da.setUint16(this.engineVersionMinor);
		if (da.hasError) { return false; }
		da.setUint16(this.engineVersionPatch);
		if (da.hasError) { return false; }
		da.setBool(this.diagonalMovement);
		if (da.hasError) { return false; }
		da.setByte(this.playerStride);
		if (da.hasError) { return false; }
		da.setByte(this.playerOpenReach);
		if (da.hasError) { return false; }
		da.setByte(this.gameMode as u8);
		if (da.hasError) { return false; }
		return true;
	}
}

export class PresentCircumstances extends Message {
	lastTickDuration: u32 = 0;
	lastMoveResult: MoveResult = MoveResult.Succeeded;
	currentHitPoints: u16 = 0;
	surroundings: TileType[] = [];
	surroundingsRadius: u8 = 0;

	getMessageType() : MessageType { return MessageType.PresentCircumstancesType; }

	getSizeInBytes(): usize {
		let size: usize = 0;
		size += this.surroundings.length * 1;
		size += 10;
		return size;
	}

	static override fromBytes(data: DataView): PresentCircumstances | null {
		const da = new DataAccess(data);
		return PresentCircumstances.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): PresentCircumstances | null {
		const nPresentCircumstances = new PresentCircumstances();
		nPresentCircumstances.lastTickDuration = da.getUint32();
		if (da.hasError) { return null; }
		let _lastMoveResult = da.getByte();
		if (da.hasError) { return null; }
		if (_lastMoveResult < 0 || _lastMoveResult >= (MoveResult._Unknown as u8)) {
			_lastMoveResult = MoveResult._Unknown as u8;
		}
		nPresentCircumstances.lastMoveResult = _lastMoveResult;
		nPresentCircumstances.currentHitPoints = da.getUint16();
		if (da.hasError) { return null; }
		const surroundings_Length = da.getUint16();
		if (da.hasError) { return null; }
		nPresentCircumstances.surroundings = new Array<TileType>(surroundings_Length);
		for (let i2: u16 = 0; i2 < surroundings_Length; i2++) {
			let _surroundings = da.getByte();
			if (da.hasError) { return null; }
			if (_surroundings < 0 || _surroundings >= (TileType._Unknown as u8)) {
				_surroundings = TileType._Unknown as u8;
			}
			nPresentCircumstances.surroundings[i2] = _surroundings;
		}
		nPresentCircumstances.surroundingsRadius = da.getByte();
		if (da.hasError) { return null; }
		return nPresentCircumstances;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.PresentCircumstancesType as u8);
			if (da.hasError) { return false; }
		}
		da.setUint32(this.lastTickDuration);
		if (da.hasError) { return false; }
		da.setByte(this.lastMoveResult as u8);
		if (da.hasError) { return false; }
		da.setUint16(this.currentHitPoints);
		if (da.hasError) { return false; }
		da.setUint16(this.surroundings.length as u16);
		if (da.hasError) { return false; }
		for (let i = 0; i < this.surroundings.length; i++) {
			let el = this.surroundings[i];
			da.setByte(el as u8);
			if (da.hasError) { return false; }
		}
		da.setByte(this.surroundingsRadius);
		if (da.hasError) { return false; }
		return true;
	}
}

export class Wait extends Message {

	getMessageType() : MessageType { return MessageType.WaitType; }

	getSizeInBytes(): usize {
		return 0;
	}

	static override fromBytes(data: DataView): Wait | null {
		const da = new DataAccess(data);
		return Wait.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): Wait | null {
		const nWait = new Wait();
		return nWait;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.WaitType as u8);
			if (da.hasError) { return false; }
		}
		return true;
	}
}

export class Resign extends Message {

	getMessageType() : MessageType { return MessageType.ResignType; }

	getSizeInBytes(): usize {
		return 0;
	}

	static override fromBytes(data: DataView): Resign | null {
		const da = new DataAccess(data);
		return Resign.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): Resign | null {
		const nResign = new Resign();
		return nResign;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.ResignType as u8);
			if (da.hasError) { return false; }
		}
		return true;
	}
}

export class MoveTo extends Message {
	direction: Direction = Direction.North;
	distance: u8 = 0;

	getMessageType() : MessageType { return MessageType.MoveToType; }

	getSizeInBytes(): usize {
		return 2;
	}

	static override fromBytes(data: DataView): MoveTo | null {
		const da = new DataAccess(data);
		return MoveTo.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): MoveTo | null {
		const nMoveTo = new MoveTo();
		let _direction = da.getByte();
		if (da.hasError) { return null; }
		if (_direction < 0 || _direction >= (Direction._Unknown as u8)) {
			_direction = Direction._Unknown as u8;
		}
		nMoveTo.direction = _direction;
		nMoveTo.distance = da.getByte();
		if (da.hasError) { return null; }
		return nMoveTo;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.MoveToType as u8);
			if (da.hasError) { return false; }
		}
		da.setByte(this.direction as u8);
		if (da.hasError) { return false; }
		da.setByte(this.distance);
		if (da.hasError) { return false; }
		return true;
	}
}

export class Open extends Message {
	target: Point = new Point();

	getMessageType() : MessageType { return MessageType.OpenType; }

	getSizeInBytes(): usize {
		return 4;
	}

	static override fromBytes(data: DataView): Open | null {
		const da = new DataAccess(data);
		return Open.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): Open | null {
		const nOpen = new Open();
		const _target = Point.fromBytes(da);
		if (_target == null) {
			return null;
		}
		else {
			nOpen.target = _target;
		}
		return nOpen;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.OpenType as u8);
			if (da.hasError) { return false; }
		}
		if (!this.target.writeBytes(da)) { return false; };
		return true;
	}
}

export class Close extends Message {
	target: Point = new Point();

	getMessageType() : MessageType { return MessageType.CloseType; }

	getSizeInBytes(): usize {
		return 4;
	}

	static override fromBytes(data: DataView): Close | null {
		const da = new DataAccess(data);
		return Close.fromBytesDA(da);
	}

	static override fromBytesDA(da: DataAccess): Close | null {
		const nClose = new Close();
		const _target = Point.fromBytes(da);
		if (_target == null) {
			return null;
		}
		else {
			nClose.target = _target;
		}
		return nClose;
	}

	writeBytes(data: DataView, tag: boolean): bool {
		const da = new DataAccess(data);
		return this.writeBytesDA(da, tag);
	}

	writeBytesDA(da: DataAccess, tag: boolean): bool {
		if (tag) {
			da.setByte(MessageType.CloseType as u8);
			if (da.hasError) { return false; }
		}
		if (!this.target.writeBytes(da)) { return false; };
		return true;
	}
}

